---
layout: post
title: (Day 273)
categories: [theory,gnn]
---

# Hello :) Today is Day 273!
A quick summary of today:

## Ch. 4 Exploratory graph analysis

### 4.1 Exploring the Twitter network

When going into a neo4j database, by default there is some information about the graph

![image](https://github.com/user-attachments/assets/14277dd1-5b13-4f65-b0f6-f1ea049ce142)

We can visualisa the graph using

```cypher
MATCH p=()-[r :FOLLOWS]->()
RETURN p LIMIT 25;
```

![image](https://github.com/user-attachments/assets/6dbb0af0-ac55-4c72-ada8-b8a9988b75ff)

### 4.2 Aggregating data with Cypher query language

Example:

Calculating the ratio of non-null values of `registeredAt` node property

```cypher
MATCH (u:User)
WITH count(*) AS numberOfRows,
     count(u.registeredAt) AS usersWithRegisteredAtDate
RETURN toFloat(usersWithRegisteredAtDate) / numberOfRows * 100 AS result
```

**NOTE** In Neo4j, when we divide an integer value by another integer value, the result will also be the integer data type. If we want the result to be of the float type we need to cast either of the variables to float using the toFloat() function

Counting the number of nodes by labels

```cypher
MATCH (n)
RETURN labels(n) AS labels,
       count(n) AS count;
```

Retrieving the earliest and last created date values of tweets

```cypher
MATCH (n:Tweet)
RETURN min(n.createdAt) AS earliestDate, max(n.createdAt) as lastDate
```

Extracting datetime attributes

```cypher
MATCH (t:Tweet)
WITH t LIMIT 1
RETURN t.createdAt.year AS year,
       t.createdAt.month AS month,
       t.createdAt.day AS day,
       t.createdAt.epochSeconds AS epochSeconds;
```

### 4.3 Filtering graph patterns

Counting the number of users who were mentioned in a tweet and discounting the retweet mention pattern with an existential subquery

```cypher
MATCH (u:User)<-[:MENTIONS]-(tweet:Tweet)
WHERE NOT EXISTS {
  (original)<-[:PUBLISH]-(u)<-[:MENTIONS]-(tweet)-[:RETWEETS]->(original)
}
RETURN count(distinct u) AS countOfUsers
```

### 4.4 Counting subqueries

Retrieving the top five most mentioned users

```cypher
MATCH (u:User)<-[:MENTIONS]-(:Tweet)
WITH u, count(*) AS mentions
ORDER BY mentions DESC LIMIT 5
RETURN u.username AS user, mentions
```

There is nothing wrong with the statement above. However, you will frequently be performing multiple aggregations in a single query. When performing multiple aggregations in a query, you must be very mindful of the query cardinality (number of intermediate rows in the query). A simple yet very effective syntax to not increase the cardinality when counting the number of relationships a node has is to use the count {} operator and describe the desired graph pattern you want to count, as shown in the following listing.

Convenient way of retrieving the top five most mentioned users by not increasing main query cardinality

```cypher
MATCH (u:User)
WITH u, count { (u)<-[:MENTIONS]-() } AS mentions
ORDER BY mentions DESC LIMIT 5
RETURN u.username AS user, mentions
```

### 4.5 Multiple aggregations in sequence

when performing multiple aggregation in sequence we must be careful with the intermediate cardinality

Say we have 2 MATCH clauses in a row

```cypher
MATCH (u:User)
MATCH (t:Tweet)
RETURN count(*) AS numberOfRows,
       count(u) AS countOfUsers,
       count(t) AS countOfTweets
```

The cardinality problem in Cypher queries arises when we have multiple MATCH or OPTIONAL MATCH clauses executed in sequence without reducing the intermediate results. Each MATCH or OPTIONAL MATCH clause produces a number of rows, and if we don’t control this, subsequent clauses will be executed for every row produced by the previous one. This can lead to an exponential growth in the number of rows, causing inefficient queries and incorrect results.

To prevent this, we should reduce the cardinality after each MATCH or OPTIONAL MATCH clause before moving on to the next one. The key techniques are:

* Using Aggregating Functions: after each MATCH clause, we can use an aggregation function like count() to reduce the number of rows produced

```cypher
MATCH (u:User)
WITH count(u) AS countOfUsers
MATCH (t:Tweet)
RETURN count(*) AS numberOfRows, countOfUsers, count(t) AS countOfTweets
```

This reduces the number of rows between the MATCH clauses, allowing subsequent clauses to be executed only once.

* Using the WITH Clause: we can reduce intermediate results by using WITH to pass along only the necessary data; by aggregating after each MATCH we ensure that subsequent MATCH clauses operate on a single or a reduced set of rows, avoiding exponential row growth

Example:

```cypher
MATCH (u:User)
WHERE u.username = "IainLJBrown" 
OPTIONAL MATCH (u)-[:PUBLISH]->(rt)<-[:RETWEETS]-()
WITH u, count(rt) AS numberOfRetweets 
OPTIONAL MATCH (u)<-[:MENTIONS]-(t)
WHERE NOT (t)-[:RETWEETS]->()
WITH u, numberOfRetweets, count(t) AS mentionsInOriginalTweets 
OPTIONAL MATCH (u)<-[:MENTIONS]-(ort)
WHERE (ort)-[:RETWEETS]->() AND NOT (ort)-[:RETWEETS]->()<-[:PUBLISH]-(u)
WITH u, numberOfRetweets, mentionsInOriginalTweets, count(ort) AS mentionsInRetweets
RETURN u.username AS user, numberOfRetweets, mentionsInOriginalTweets, mentionsInRetweets
```

In the above query, after each OPTIONAL MATCH clause, the cardinality is reduced using the count() function. This ensures the query doesn’t balloon out of control in terms of the number of rows, and each clause is executed only once for the necessary entities.

## Ch. 5 Introduction to social network analysis

An essential aspect of characterizing any network is to look at the node degree distribution. In simple terms, the node degree is the number of links each node has. In a random network, the degree distribution will follow the Gaussian distribution

![image](https://github.com/user-attachments/assets/f6cac7de-1302-4d63-a722-92a77f8e074f)

The vast majority of nodes have roughly the same number of links. There won’t be many hugely popular nodes, but there won’t be many isolated nodes either.


However, the Gaussian distribution is most often used for independent observations. On the other hand, a graph consists of highly interconnected observations that are not independent. It turns out that almost no real-world network follows the random network degree distribution

When PageRank was developed by Google, they discovered that **the web** degree distribution follows a different pattern

![image](https://github.com/user-attachments/assets/c67dd23c-8e05-4c08-be71-a87b051d5fac)


### 5.1 Follower network

This chapter will introduce some community detection and centrality graph algorithms. The **community detection algorithms** will be used to characterize the network and also find tightly connected groups of users. In the context of networks, a community refers to a densely connected group of nodes, whose members have comparatively fewer connections to other communities in the network

![image](https://github.com/user-attachments/assets/41762e52-3c55-44ab-b283-bdc109a0e67f)

The metrics used to identify important or influential nodes in the graph are called centrality measures, and the algorithms that calculate them are called **centrality algorithms**. For example, the most basic metric to determine a node’s importance is degree centrality, which simply counts the number of relationships a node has. The higher the count of relationships is, the more influential the node is in the network.

**Node degree distribution**

One of the fundamental characteristics of a network is the node degree distribution. With a directed network, you can split the degree distribution into in-degree and out-degree distribution. The node in-degree counts the number of incoming relationships, and the out-degree counts the number of outgoing connections per node.

Evaluating the node out-degree distribution with the apoc.agg.statistics function

```cypher
MATCH (u:User)
WITH u, count{ (u)-[:FOLLOWS]->() } AS outDegree
RETURN apoc.agg.statistics(outDegree)
```

| Metric      | Value               |
|-------------|---------------------|
| Total       | 3,594               |
| Min         | 0                   |
| MinNonZero  | 1.0                 |
| Max         | 143                 |
| Mean        | 6.924874791318865   |
| 0.5 (Median)| 2                   |
| 0.99        | 57                  |
| 0.75        | 8                   |
| 0.9         | 21                  |
| 0.95        | 32                  |
| Stdev       | 11.94885358058576   |

Node out-degree distribution users' follows

![image](https://github.com/user-attachments/assets/cbb5db8e-f2d0-4e91-846c-b23789fcf76f)

### 5.2 Introduction to the Neo4j Graph Data Science library














